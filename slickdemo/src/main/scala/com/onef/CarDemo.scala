package com.onef

import java.nio.file.{Files, Paths}

import javax.sql.rowset.serial.SerialBlob
import slick.jdbc.H2Profile.backend.Database

// use postgres instead
import slick.jdbc.H2Profile.api._

import scala.concurrent.Await
import scala.concurrent.duration.Duration

import scala.concurrent.ExecutionContext.Implicits.global

object CarDemo {
  def main(args: Array[String]): Unit = {
    val newCar = tupledCreation()

    // loading DB config stored in Typesafe Config format
    val db = Database.forConfig("car")

    // TODO abstract over database type ( see ES 5.1.1 )
    createDbSchema(db)

    insertNewCars(db)

    // TODO load records from DB
    selectAllCars(db)

    selectCarByModel(db, "320d")
  }

  private def selectCarByModel(db: Database, model: String): Option[Car] = {
    println(s"selecting record from CAR table by model = $model")

    val cars = TableQuery[CarTable]

    // === generated by ExtensionMethodConversions.columnExtensionMethods
    // right hand side ( model argument ) converted using api.valueToConstColumn
    val selectionAction = cars
      .filter(c => c.model === model)
      .result

    Await.result(db.run(selectionAction), Duration.Inf)
      .headOption
  }

  private def selectCarByModelExplicitly(db: Database, model: String): Option[Car] = {
    val cars = TableQuery[CarTable]

    slick.jdbc.H2Profile.api.streamableQueryActionExtensionMethods[com.onef.CarTable#TableElementType, Seq](
      cars.filter[slick.lifted.Rep[Boolean]](
        (c: com.onef.CarTable) => slick.jdbc.H2Profile.api.columnExtensionMethods[String](c.model)(slick.jdbc.H2Profile.api.stringColumnType)
          .===[String, Boolean](slick.jdbc.H2Profile.api.valueToConstColumn[String](model)(slick.jdbc.H2Profile.api.stringColumnType))
      ) // end of filter
    )

    // filter allowed types constrained by .filter implicit argument CanBeQueryCondition
    val selectAction = cars
      .filter(c => {
        val carModel: Rep[String] = c.model

        // H2Profile.api._
        // the same as expression below which uses LiteralColumn directly
        // val carModelArg = valueToConstColumn(model)
        val carModelArg: Rep[String] = LiteralColumn(model)

        // val rv: Rep[Boolean] = LiteralColumn(true)
        // columnExtensionMethods returns BaseColumnExtensionMethods
        val rv: Rep[Boolean] = columnExtensionMethods(c.model) === carModelArg

        rv
      })
      .result

    None
  }

  private def selectAllCars(db: Database): Unit = {
    println("selecting all records from CAR table")

    val cars = TableQuery[CarTable]

    val selectedCars = Await.result(db.run(cars.result), Duration.Inf)

    println(s"selected cars: $selectedCars")
  }

  private def insertNewCars(db: Database): Unit = {
    println("inserting new records to CAR table")

    val imageBytes = Files.readAllBytes(Paths.get(sys.props("user.home"), "Downloads", "320d.jpg"))
    val imageBlob = new SerialBlob(imageBytes)

    import Owners.Owners

    // 1. insert owner
    val ownersReturningId = Owners returning Owners.map(_.id)

    val ownerCreationAction = ownersReturningId += Owner("Billy", "Bones")

    import Cars.Cars

    def insertCars(ownerId: Long) = Cars ++= Seq(
      Car("BMW", "320d", imageBlob, ownerId),
      Car("BMW", "325d", imageBlob, ownerId))

    val insert = ownerCreationAction.flatMap { ownerId =>
      insertCars(ownerId)
    }

    val insertActionResult = Await.result(db.run(insert.transactionally), Duration.Inf)

    println("records added to CAR table with result: " + insertActionResult)
  }

  private def createDbSchema(db: Database): Unit = {
    println("creating DB schema")

    val schemaCreationAction = Owners.Owners.schema.create andThen Cars.Cars.schema.create

    val createTableActivity = db.run(schemaCreationAction)
    Await.ready(createTableActivity, Duration.Inf)

    println(s"DB schema creation activity: $createTableActivity")
  }

  private def tupledCreation(): Car = {
    val imageBlob = new SerialBlob(Array.empty[Byte])
    val ownerId = 2L
    val carTuple = ("BMW", "320d", imageBlob, ownerId, 1L)

    val car = Car.tupled(carTuple)

    println(s"car: $car")

    car
  }
}
