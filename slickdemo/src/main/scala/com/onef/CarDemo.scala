package com.onef

import slick.jdbc.H2Profile.backend.Database

// use postgres instead
import slick.jdbc.H2Profile.api._

import scala.concurrent.Await
import scala.concurrent.duration.Duration

object CarDemo {
  def main(args: Array[String]): Unit = {
    val newCar = tupledCreation()

    // loading DB config stored in Typesafe Config format
    val db = Database.forConfig("car")

    // TODO abstract over database type ( see ES 5.1.1 )
    createCarTable(db)

    insertNewCars(db)

    // TODO load records from DB
    selectAllCars(db)

    selectCarByModel(db, "320d")
  }

  private def selectCarByModel(db: Database, model: String): Option[Car] = {
    println(s"selecting record from CAR table by model = $model")

    val cars = TableQuery[CarTable]

    // === generated by ExtensionMethodConversions.columnExtensionMethods
    // right hand side ( model argument ) converted using api.valueToConstColumn
    val selectionAction = cars
      .filter(c => c.model === model)
      .result

    Await.result(db.run(selectionAction), Duration.Inf)
      .headOption
  }

  private def selectCarByModelExplicitly(db: Database, model: String): Option[Car] = {
    val cars = TableQuery[CarTable]

    slick.jdbc.H2Profile.api.streamableQueryActionExtensionMethods[com.onef.CarTable#TableElementType, Seq](
      cars.filter[slick.lifted.Rep[Boolean]](
        (c: com.onef.CarTable) => slick.jdbc.H2Profile.api.columnExtensionMethods[String](c.model)(slick.jdbc.H2Profile.api.stringColumnType)
          .===[String, Boolean](slick.jdbc.H2Profile.api.valueToConstColumn[String](model)(slick.jdbc.H2Profile.api.stringColumnType))
      ) // end of filter
    )

    // filter allowed types constrained by .filter implicit argument CanBeQueryCondition
    val selectAction = cars
      .filter(c => {
        val carModel: Rep[String] = c.model

        // H2Profile.api._
        // the same as expression below which uses LiteralColumn directly
        // val carModelArg = valueToConstColumn(model)
        val carModelArg: Rep[String] = LiteralColumn(model)

        // val rv: Rep[Boolean] = LiteralColumn(true)
        // columnExtensionMethods returns BaseColumnExtensionMethods
        val rv: Rep[Boolean] = columnExtensionMethods(c.model) === carModelArg

        rv
      })
      .result

    None
  }

  private def selectAllCars(db: Database): Unit = {
    println("selecting all records from CAR table")

    val cars = TableQuery[CarTable]

    val selectedCars = Await.result(db.run(cars.result), Duration.Inf)

    println(s"selected cars: $selectedCars")
  }

  private def insertNewCars(db: Database): Unit = {
    println("inserting new records to CAR table")

    // TODO can be expressed as val cars = TableQuery[Cars]
    val car = TableQuery[CarTable]

    val insert = car ++= Seq(Car("BMW", "320d"), Car("BMW", "325d"))

    val insertActionResult = Await.result(db.run(insert), Duration.Inf)

    println("records added to CAR table")

  }

  private def createCarTable(db: Database): Unit = {
    println("creating CAR table")

    val carTable = TableQuery[CarTable]

    // all schema creation actions should be combined using asTry to

    val createTableActivity = db.run(carTable.schema.create)
    Await.ready(createTableActivity, Duration.Inf)

    println(s"CAR table creation activity: $createTableActivity")
  }

  private def tupledCreation(): Car = {
    val carTuple = ("BMW", "320d", 1L)

    val car = Car.tupled(carTuple)

    println(s"car: $car")

    car
  }
}
